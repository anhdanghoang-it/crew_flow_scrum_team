technical_design_task:
  description: >
    INPUT SOURCES:
    - User Stories: from Product Manager - includes UI/UX requirements and user-facing messages: <USER_STORIES>user_stories</USER_STORIES>
    - Business Requirements: raw client requirements for the software feature: <REQUIREMENTS>requirements</REQUIREMENTS>
    - Module Name: Python module name to design: <MODULE_NAME>module_name</MODULE_NAME>
    - Class Name: Primary class name to implement: <CLASS_NAME>class_name</CLASS_NAME>

    ## Your Task

    Transform user stories and business requirements into production-ready technical designs by:

    1. **Analyzing Input**:
      - Review user stories from Product Manager for UI/UX requirements and user-facing messages
      - Extract technical requirements from business requirements
      - Identify data models, workflows, and integration points
      - Clarify ambiguities and technical constraints
      - Use the specified module name: {module_name} and primary class name: {class_name}

    2. **Designing Backend (Python)**:
      - Design a self-contained Python module: {module_name} with primary class: {class_name}
      - Define module structure with clear responsibility boundaries
      - Specify all classes, methods, and functions with complete signatures
      - Create data models using Pydantic or dataclasses
      - Design error handling with specific exception types
      - Document backend response formats for UI consumption

    3. **Designing Frontend (Gradio)**:
      - Map backend functionality to Gradio components
      - Design UI layout and user workflows
      - Specify all user-facing messages and feedback mechanisms
      - Define input validation and error display strategies
      - Ensure accessibility and usability requirements

    4. **Defining Integration**:
      - Document how Gradio calls Python backend methods
      - Create data flow diagrams showing end-to-end workflows
      - Map user story messages to specific UI elements
      - Define testing strategies for backend, frontend, and integration

    5. **Ensuring Implementation Readiness**:
      - Provide code examples and templates
      - Include docstring templates following Google or NumPy style
      - Specify dependencies and setup requirements
      - Define Definition of Done criteria
  expected_output: >
    A comprehensive technical design document in markdown format containing:

    ### Document Structure:

    #### 1. Overview & Architecture
    - High-level system architecture diagram
    - Technology stack (Python version, Gradio version, key dependencies)
    - Module organization and file structure
    - Design principles and patterns used
    - Integration architecture (backend ↔ frontend)

    #### 2. Python Backend Design
    - **Module Structure**:
      - File organization and naming conventions
      - Package structure and imports
      - Dependency management (requirements.txt or pyproject.toml)
      
    - **Class Definitions**:
      - Primary class with complete method signatures
      - Type hints for all parameters and return values
      - Comprehensive docstrings (Google or NumPy style)
      - Properties, class methods, static methods
      
    - **Data Models/Schemas**:
      - Pydantic models or dataclasses for all domain objects
      - Validation rules and constraints
      - Serialization/deserialization strategies
      
    - **Error Handling Strategy**:
      - Custom exception hierarchy
      - Error messages and error codes
      - Exception handling patterns
      
    - **Backend Response Format**:
      - Standard success response structure
      - Standard error response structure
      - Data formatting for UI consumption

    #### 3. Gradio Frontend Design
    - **UI Component Mapping**:
      - Table mapping backend methods → Gradio components
      - Component configurations and properties
      - Event handlers and callbacks
      
    - **User-Facing Messages**:
      - Success messages (gr.Info)
      - Error messages (gr.Error)
      - Warning messages (gr.Warning)
      - Informational messages
      - Loading states and progress indicators
      
    - **UI Layout & Workflow**:
      - Gradio Blocks layout specification
      - Tab organization (if applicable)
      - Row/Column arrangements
      - User interaction flows
      - State management
      
    - **Input Validation & Error Display**:
      - Client-side validation rules
      - Error message display strategies
      - Field-level vs form-level validation
      - Accessibility considerations

    #### 4. Integration Points
    - **Backend-Frontend Communication**:
      - Function call patterns (sync vs async)
      - Data passing conventions
      - Error propagation strategies
      
    - **Data Flow Diagrams**:
      - User input → Backend processing → UI display
      - Error handling flows
      - State update flows
      
    - **Message Mapping**:
      - User story requirements → UI elements
      - Backend error codes → User-facing messages
      - Success scenarios → Confirmation messages

    #### 5. Implementation Examples
    - **Backend Usage Examples**:
      - Class instantiation
      - Method invocation patterns
      - Error handling examples
      - Unit test examples
      
    - **Frontend Integration Examples**:
      - Complete Gradio app skeleton
      - Event handler implementations
      - State management examples
      - Error display examples

    #### 6. Testing & QA Guidelines
    - **Backend Testing**:
      - Unit test requirements
      - Test data and fixtures
      - Coverage expectations
      
    - **Frontend Testing**:
      - UI component testing
      - User workflow testing
      - Accessibility testing
      
    - **Integration Testing**:
      - End-to-end test scenarios
      - QA validation points from user stories
      - Performance testing requirements

    #### 7. Dependencies & Setup
    - Required Python packages with versions
    - Gradio version and configuration
    - Development environment setup
    - Deployment considerations

    #### 8. Definition of Done
    - Code completion checklist
    - Testing requirements
    - Documentation requirements
    - Performance criteria
    - Accessibility compliance
    
    ### Quality Standards

    Your technical design must:
    - ✅ Be immediately implementable by developers without additional clarification
    - ✅ Include complete type hints for all Python code examples
    - ✅ Specify exact Gradio component types and configurations
    - ✅ Map all user-facing messages from user stories to UI elements
    - ✅ Provide clear separation between backend logic and UI concerns
    - ✅ Enable independent development of backend and frontend
    - ✅ Include sufficient examples to eliminate ambiguity
    - ✅ Address all acceptance criteria from user stories
    - ✅ Define clear testing strategies for QA validation
    - ✅ Be version-controlled and maintainable as requirements evolve    
  agent: engineering_lead
  output_file: /docs/crew/trading_simulation_technical_design.md

# technical_design_task:
#   description: >
#     Create a comprehensive technical design document that bridges Python backend and Gradio frontend development.
    
#     INPUT SOURCES:
#     - User Stories: from Product Manager - includes UI/UX requirements and user-facing messages: <USER_STORIES>{user_stories}</USER_STORIES>
#     - Business Requirements: raw client requirements for the software feature: <REQUIREMENTS>{requirements}</REQUIREMENTS>
#     - Module Name: Python module name to design: <MODULE_NAME>{module_name}</MODULE_NAME>
#     - Class Name: Primary class name to implement: <CLASS_NAME>{class_name}</CLASS_NAME>
    
#     BACKEND DESIGN REQUIREMENTS (Python):
#     - Design a self-contained Python module named '{module_name}' with primary class '{class_name}'
#     - Specify all public methods with complete signatures, type hints, parameters, return types, and docstrings
#     - Define data structures, schemas, and domain models
#     - Document error handling strategies with specific exception types and error messages
#     - Ensure backend returns structured responses (success/error messages, data) suitable for UI display
#     - Make the module immediately testable and production-ready
    
#     FRONTEND DESIGN REQUIREMENTS (Gradio):
#     - Map each backend method to appropriate Gradio UI components (Textbox, Number, Dropdown, Button, etc.)
#     - Specify exact user-facing messages (success, error, info, warnings) for all operations
#     - Define UI layout, component organization, and user workflow through the Gradio interface
#     - Document how backend responses are displayed in the UI (formatted text, tables, alerts)
#     - Include input validation requirements and error handling in the UI layer
    
#     INTEGRATION REQUIREMENTS:
#     - Clearly document how Gradio frontend calls Python backend methods
#     - Define data flow: user input → UI validation → backend processing → response formatting → UI display
#     - Ensure all user-facing messages defined in user stories are mapped to specific UI elements
#     - Enable QA to validate both backend logic and frontend user experience
    
#     OUTPUT FORMAT:
#     Produce a detailed markdown document with the following sections:
#     1. Overview & Architecture (Backend + Frontend integration)
#     2. Python Backend Design
#        - Module Structure
#        - Class Definitions (with all methods and properties)
#        - Data Models/Schemas
#        - Error Handling Strategy
#        - Backend Response Format
#     3. Gradio Frontend Design
#        - UI Component Mapping (backend method → Gradio component)
#        - User-Facing Messages (success, error, info)
#        - UI Layout & Workflow
#        - Input Validation & Error Display
#     4. Integration Points
#        - Backend-Frontend Communication
#        - Data Flow Diagrams
#        - Message Mapping (user stories → UI elements)
#     5. Implementation Examples
#        - Backend Usage Examples
#        - Frontend Integration Examples
#     6. Testing & QA Guidelines
    
#     IMPORTANT: 
#     - Output ONLY the design document in markdown format
#     - Be implementation-ready for both backend (Python) and frontend (Gradio) developers
#     - Include docstring templates for all classes and methods
#     - Specify exact Gradio component types and configurations
#     - Map all user-facing messages to specific UI elements
#   expected_output: >
#     A comprehensive technical design document in markdown format containing:
#     BACKEND SECTION:
#     - Complete Python module structure with '{module_name}' as the module name
#     - Primary class '{class_name}' with full method signatures and type hints
#     - All supporting classes, functions, and data structures
#     - Error handling with specific exception types and messages
#     - Structured response formats for UI consumption
    
#     FRONTEND SECTION:
#     - Gradio UI component mapping for each backend method
#     - Complete list of user-facing messages (success, error, info, warnings)
#     - UI layout specification with Gradio Blocks/Interface
#     - Input validation and error display strategies
    
#     INTEGRATION SECTION:
#     - Clear data flow from user input to UI display
#     - Backend method → Gradio component mapping table
#     - User story messages → UI element mapping
#     - QA validation points for end-to-end workflows
#   agent: engineering_lead
#   output_file: /docs/crew/trading_simulation_technical_design.md