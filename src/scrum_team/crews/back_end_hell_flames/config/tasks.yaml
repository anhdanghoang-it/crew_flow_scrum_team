implement_backend_module:
  description: >
    Transform the Engineering Lead's technical design and Product Manager's user stories into production-ready Python code.
    INPUT SOURCES:
    - User Stories: from Product Manager - includes UI/UX requirements and user-facing messages: ```{user_stories}```
    - Technical Design: detailed design document from Engineering Lead: ```{technical_design}```

    YOUR TASK:
    
    1. Analyzing Input:
       - Review technical design document from Engineering Lead for exact specifications
       - Extract all class definitions, method signatures, and data models
       - Review user stories from Product Manager for acceptance criteria and validation requirements
       - Identify all user-facing messages (success, error, info) to implement
       - Clarify data flow and integration points with Gradio frontend
    
    2. Implementing Backend Module:
       - Create module with exact structure specified in technical design
       - Implement all classes with complete method signatures and type hints
       - Add comprehensive docstrings (Google or NumPy style as specified)
       - Implement all data models using Pydantic or dataclasses as designed
       - Create custom exception hierarchy as specified
       - Implement all business logic to fulfill user story requirements
    
    3. Ensuring Frontend Integration:
       - Return structured responses: {'success': bool, 'message': str, 'data': Any}
       - Format data for Gradio components (DataFrames for tables, lists for dropdowns, etc.)
       - Implement all user-facing messages from user stories
       - Ensure error messages are actionable and user-friendly
       - Handle edge cases with appropriate error responses
    
    4. Quality Assurance:
       - Validate all inputs with clear error messages
       - Handle all edge cases defined in user stories
       - Follow PEP 8 style guidelines
       - Ensure code is self-contained and testable
       - Verify all acceptance criteria are met
       - Include usage examples in docstrings
    
    5. Delivering Production-Ready Code:
       - Output pure Python code only (no markdown, no explanations)
       - Code must be directly executable as a .py file
       - No placeholders, TODOs, or incomplete implementations
       - Ready for immediate Gradio frontend integration
       - Ready for unit testing and QA validation
    
    INPUTS PROVIDED:
    - Technical design document with class definitions, method signatures, and architecture
    - User stories with acceptance criteria and validation requirements
    - Feature name and module name for file naming
    
    MODULE STRUCTURE REQUIREMENTS:
    
    1. Module-Level Documentation with:
       - Module name and purpose
       - Brief description of functionality
       - List of classes with descriptions
       - List of functions with descriptions
       - Usage example
       - Dependencies list
    
    2. Imports (grouped and sorted):
       - Standard library imports
       - Third-party imports
       - Local imports
       - Type hints from typing module
    
    3. Constants and Configuration:
       - Module-level constants
       - Configuration values
       - Default settings
       - Named constants replacing magic numbers
    
    4. Custom Exception Classes:
       - Exception hierarchy as specified in design
       - Clear error messages
       - Error codes for programmatic handling
    
    5. Data Models:
       - Using Pydantic BaseModel or dataclasses
       - Complete field definitions with type hints
       - Validators for all constraints
    
    6. Primary Class Implementation:
       - Complete initialization
       - All public methods with type hints and docstrings
       - Structured return values for Gradio integration
       - Private helper methods
       - Usage examples in docstrings
    
    7. Supporting Classes and Functions:
       - Helper classes as specified
       - Utility functions
       - Data transformation functions
       - Validation functions
    
    CODE QUALITY CHECKLIST - Your implementation MUST satisfy ALL of these:
    ✅ Follows exact specifications from technical design document
    ✅ Implements all user story requirements and acceptance criteria
    ✅ Includes comprehensive type hints for all functions and methods
    ✅ Contains detailed docstrings with examples for all public APIs
    ✅ Returns structured responses compatible with Gradio UI display
    ✅ Implements all user-facing messages from user stories
    ✅ Validates all inputs with clear error messages
    ✅ Handles all edge cases and error scenarios
    ✅ Follows PEP 8 style guidelines
    ✅ Is self-contained and testable without modifications
    ✅ Contains NO markdown formatting, code fences, or explanatory text
    ✅ Is production-ready with zero placeholders or TODOs
    ✅ Starts directly with imports or module docstring
  
  expected_output: >
    A complete, production-ready Python module file containing:
    
    CRITICAL OUTPUT FORMAT:
    - Pure Python code ONLY
    - NO markdown code fences (```)
    - NO explanatory text before or after the code
    - NO comments outside the module itself
    - Directly saveable to a .py file
    - Immediately executable
    
    START your response with either:
    - """ (module docstring), or
    - import / from (if no module docstring)
    
    DO NOT START with:
    - "```python"
    - "Here's the implementation:"
    - "# Implementation"
    - Any explanatory text
    
    The code must include:
    
    1. Module docstring with overview, classes, functions, usage example, and dependencies
    2. All imports properly organized
    3. Constants and configuration values
    4. Custom exception classes with proper error handling
    5. Data models using Pydantic or dataclasses
    6. Primary class with:
       - Complete __init__ method
       - All public methods returning {'success': bool, 'message': str, 'data': Any}
       - Comprehensive type hints
       - Detailed docstrings with examples
       - Input validation
       - Error handling
    7. Helper classes and utility functions as needed
    
    File naming: [feature_name]_[module_name].py
    Save location: /src/crew_generated/engineering/
    
    The output must be copy-pasteable directly into a .py file and run without any modifications.
  
  agent: backend_dev_hell_flames
  output_file: /src/crew_generated/engineering/trading_simulation_backend.py
